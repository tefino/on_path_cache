<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NB_Blackadder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>NB_Blackadder Class Reference</h1><!-- doxytag: class="NB_Blackadder" -->
<p>(User Library) This is the wrapper class that makes the service model available to all applications in a Non-Blocking manner.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nb__blackadder_8hpp_source.html">nb_blackadder.hpp</a>&gt;</code></p>

<p><a href="classNB__Blackadder-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a91878d3d55d351fb617c04cdfbbce738">~NB_Blackadder</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor: It closes the socket.  <a href="#a91878d3d55d351fb617c04cdfbbce738"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a7411bebc92c46cad19844b00b2b9be38">publish_scope</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a PUBLISH_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#a7411bebc92c46cad19844b00b2b9be38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a6300367f4cb41cb34e3b4231c764350f">publish_info</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a PUBLISH_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#a6300367f4cb41cb34e3b4231c764350f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a02f4b85a67a19e9535a8de34c2c730ac">unpublish_scope</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a UNPUBLISH_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#a02f4b85a67a19e9535a8de34c2c730ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#aac75d9e9c5eae56450d48866b85e3ae7">unpublish_info</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a UNPUBLISH_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#aac75d9e9c5eae56450d48866b85e3ae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a6668b38f60d9326e406a1f4f8c1ccfbe">subscribe_scope</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a SUBSCRIBE_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#a6668b38f60d9326e406a1f4f8c1ccfbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a4c58d8d15f0696bdfa51e70ffbe43b4e">subscribe_info</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a SUBSCRIBE_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#a4c58d8d15f0696bdfa51e70ffbe43b4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#aaf41b36a23f9a9923dcdde161163fedf">unsubscribe_scope</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a UNSUBSCRIBE_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#aaf41b36a23f9a9923dcdde161163fedf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#aa20177b292e2abba76953607140e8fc3">unsubscribe_info</a> (const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a UNSUBSCRIBE_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#aa20177b292e2abba76953607140e8fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#aab9ba1b7362f0ee5716726ffd6ecfab6">publish_data</a> (const string &amp;id, char strategy, void *str_opt, unsigned int str_opt_len, void *data, int data_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method will send a PUBLISH_DATA request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b>  <a href="#aab9ba1b7362f0ee5716726ffd6ecfab6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a4714d610909d62f9f1de2b9e0958ee9d">disconnect</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method will send a disconnect signal to <a class="el" href="classBlackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">Blackadder</a>.  <a href="#a4714d610909d62f9f1de2b9e0958ee9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a136fb87bb99f7a91da894075e0f85429">setCallback</a> (<a class="el" href="classNB__Blackadder.html#aa3131e1b0f023cf525c688bd54d095e1">callbacktype</a> t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this method registers a user provided call back with <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a>  <a href="#a136fb87bb99f7a91da894075e0f85429"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a4f9489e543ad7708682813086b140eac">join</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method MUST be called by the application so that the main function will not end before the <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> threads end.  <a href="#a4f9489e543ad7708682813086b140eac"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNB__Blackadder.html">NB_Blackadder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a5dab01297f1a3996782e0e05534dcd32">Instance</a> (bool user_space)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the Instance method is the only way to construct a <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> object. It is impossible to construct multiple objects since Instance will return the already constructed one.  <a href="#a5dab01297f1a3996782e0e05534dcd32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#aecab2849b7ee8ff81df9d2aa5b977b1d">selector</a> (void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the selector thread execution method.  <a href="#aecab2849b7ee8ff81df9d2aa5b977b1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a7bdddb82721618ddeae7be3e62f645d8">worker</a> (void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The worker thread execution method.  <a href="#a7bdddb82721618ddeae7be3e62f645d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a3897f32d9bf567384b8083c9d2648e61">signal_handler</a> (int sig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the signal handler.  <a href="#a3897f32d9bf567384b8083c9d2648e61"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a19100c8df266988e6868088ac3bdca75">selector_thread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The selector Thread (see details).  <a href="#a19100c8df266988e6868088ac3bdca75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a534bba458992a7e058e48d5bdd03243e"></a><!-- doxytag: member="NB_Blackadder::selector_mutex" ref="a534bba458992a7e058e48d5bdd03243e" args="" -->
static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a534bba458992a7e058e48d5bdd03243e">selector_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a mutex used to synchronize <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> threads. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da6aeef2139f4cdc870dae7752e5d25"></a><!-- doxytag: member="NB_Blackadder::queue_overflow_cond" ref="a3da6aeef2139f4cdc870dae7752e5d25" args="" -->
static pthread_cond_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a3da6aeef2139f4cdc870dae7752e5d25">queue_overflow_cond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this condition is used for putting a limit to the pending requests. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#ad44390459d75a021449f7beb45970dad">worker_thread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the worker thread (see details).  <a href="#ad44390459d75a021449f7beb45970dad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac17011a082299f891a8288c3bfe25b33"></a><!-- doxytag: member="NB_Blackadder::worker_mutex" ref="ac17011a082299f891a8288c3bfe25b33" args="" -->
static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#ac17011a082299f891a8288c3bfe25b33">worker_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a mutex used to synchronize <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> threads. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6aaa9a59f935a8793f9d0b5072f2fb"></a><!-- doxytag: member="NB_Blackadder::worker_cond" ref="acf6aaa9a59f935a8793f9d0b5072f2fb" args="" -->
static pthread_cond_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#acf6aaa9a59f935a8793f9d0b5072f2fb">worker_cond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the condition for which the worker thread constantly waits. It is only signaled by the selector thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ee9429180a44280453cd2e8fdfbfc78"></a><!-- doxytag: member="NB_Blackadder::read_set" ref="a3ee9429180a44280453cd2e8fdfbfc78" args="" -->
static fd_set&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a3ee9429180a44280453cd2e8fdfbfc78">read_set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the set of file descriptions that are registered for reading. Only the netlink socket sock_fd and the pipefds are used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3167beb60229829159ffb3761ef4a678"></a><!-- doxytag: member="NB_Blackadder::write_set" ref="a3167beb60229829159ffb3761ef4a678" args="" -->
static fd_set&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a3167beb60229829159ffb3761ef4a678">write_set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the set of file descriptions that are registered for writing. Only the netlink socket sock_fd and the pipefds are used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea06a798748eb086bf1c2fbfd7e9fd5"></a><!-- doxytag: member="NB_Blackadder::pipe_fds" ref="a9ea06a798748eb086bf1c2fbfd7e9fd5" args="[2]" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a9ea06a798748eb086bf1c2fbfd7e9fd5">pipe_fds</a> [2]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the file descriptors of the bidirectional pipe. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a890be365ed5bdc4977afd86afa91c29f"></a><!-- doxytag: member="NB_Blackadder::sock_fd" ref="a890be365ed5bdc4977afd86afa91c29f" args="" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a890be365ed5bdc4977afd86afa91c29f">sock_fd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the netlink socket file descriptor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a963d11ec2855e29f220eb1ecfd23f3c2"></a><!-- doxytag: member="NB_Blackadder::output_queue" ref="a963d11ec2855e29f220eb1ecfd23f3c2" args="" -->
static queue&lt; struct msghdr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a963d11ec2855e29f220eb1ecfd23f3c2">output_queue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the queue where all service model related methods put their messages that are later sent to blackadder by the selector thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af687b93a1f6948f2ede1b6585e70915b"></a><!-- doxytag: member="NB_Blackadder::event_queue" ref="af687b93a1f6948f2ede1b6585e70915b" args="" -->
static queue&lt; <a class="el" href="classEvent.html">Event</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#af687b93a1f6948f2ede1b6585e70915b">event_queue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the queue where the selector thread puts all Events sent by blackadder that are later processed by the worker thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fcf83e768b5ccb3d1bbf5c004134ea8"></a><!-- doxytag: member="NB_Blackadder::pipe_buf" ref="a8fcf83e768b5ccb3d1bbf5c004134ea8" args="[1]" -->
static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a8fcf83e768b5ccb3d1bbf5c004134ea8">pipe_buf</a> [1]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a dummy buffer for getting a dummy message from the pipe and interrupting the select() call. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d09749ee791694e9c4e7504f6f2cd4a"></a><!-- doxytag: member="NB_Blackadder::fake_buf" ref="a3d09749ee791694e9c4e7504f6f2cd4a" args="[1]" -->
static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a3d09749ee791694e9c4e7504f6f2cd4a">fake_buf</a> [1]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a dummy buffer for peeking to the actual netlink buffers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3a004a6b77a3da4b12281ff9721db98"></a><!-- doxytag: member="NB_Blackadder::cf" ref="af3a004a6b77a3da4b12281ff9721db98" args="" -->
static <a class="el" href="classNB__Blackadder.html#aa3131e1b0f023cf525c688bd54d095e1">callbacktype</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#af3a004a6b77a3da4b12281ff9721db98">cf</a> = NULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the Callback function registered with <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a>. The user must override the default by calling the <a class="el" href="classNB__Blackadder.html#a136fb87bb99f7a91da894075e0f85429" title="this method registers a user provided call back with NB_Blackadder">setCallback()</a> method. <br/></td></tr>
<tr><td colspan="2"><h2>Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3131e1b0f023cf525c688bd54d095e1"></a><!-- doxytag: member="NB_Blackadder::callbacktype" ref="aa3131e1b0f023cf525c688bd54d095e1" args=")(Event *)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#aa3131e1b0f023cf525c688bd54d095e1">callbacktype</a> )(<a class="el" href="classEvent.html">Event</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a type definition for the pointer to the callback method. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNB__Blackadder.html#a447c553da0515bfa0ffb6ef1710e23d4">defaultCallback</a> (<a class="el" href="classEvent.html">Event</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the default Callback that will be whenever an event is received if the application hasn't registered its own callback.  <a href="#a447c553da0515bfa0ffb6ef1710e23d4"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>(User Library) This is the wrapper class that makes the service model available to all applications in a Non-Blocking manner. </p>
<p>blackadder expects requests to be sent in its netlink socket. Therefore the wrapper class just exports some human-friendly methods for creating service model compliant buffers that are asynchronously sent to blackadder. <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> implements the Singleton Pattern. A single <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> object can be created by a single process using the <b>public</b> Instance method. The Constructor is <b>private</b>.</p>
<p><a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> uses two threads. A selector thread reads events when the netlink socket is readable and passes them to the worker thread. In the context of the worker thread, the callback method that <b>must be provided by the applications</b> is called with a reference to the received <a class="el" href="classEvent.html" title="(User Library) An event is what can be always expected by Blackaddder. Events are...">Event</a>.</p>
<p>The selector thread is also notified (using a pipe) to register the netlink socket for write when requests are to be forwarded to blackadder.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>All service request related methods enforce some rules regarding the size of the identifiers so that blackadder is not confused. </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a91878d3d55d351fb617c04cdfbbce738"></a><!-- doxytag: member="NB_Blackadder::~NB_Blackadder" ref="a91878d3d55d351fb617c04cdfbbce738" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NB_Blackadder::~NB_Blackadder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor: It closes the socket. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4714d610909d62f9f1de2b9e0958ee9d"></a><!-- doxytag: member="NB_Blackadder::disconnect" ref="a4714d610909d62f9f1de2b9e0958ee9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::disconnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method will send a disconnect signal to <a class="el" href="classBlackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">Blackadder</a>. </p>
<p>In user space this is required so that <a class="el" href="classBlackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">Blackadder</a> can then undo all requests the application has previously sent. In kernel this is not required since <a class="el" href="classBlackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">Blackadder</a> can monitor applications. </p>

</div>
</div>
<a class="anchor" id="a5dab01297f1a3996782e0e05534dcd32"></a><!-- doxytag: member="NB_Blackadder::Instance" ref="a5dab01297f1a3996782e0e05534dcd32" args="(bool user_space)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNB__Blackadder.html">NB_Blackadder</a> * NB_Blackadder::Instance </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>user_space</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the Instance method is the only way to construct a <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> object. It is impossible to construct multiple objects since Instance will return the already constructed one. </p>
<p>Instance will create a new object by calling the private constructor and assign it to the m_pInstance value ONLY the first time it is called. All other times it will return the m_pInstance pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_space</em>&nbsp;</td><td>if it is true, the netlink is created so that it can communicate with blackadder running in user space. if it is false, the netlink is created so that it can communicate with blackadder running in kernel space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4f9489e543ad7708682813086b140eac"></a><!-- doxytag: member="NB_Blackadder::join" ref="a4f9489e543ad7708682813086b140eac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::join </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method MUST be called by the application so that the main function will not end before the <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> threads end. </p>
<p>it calls pthread_join for the worker and selector threads. </p>

</div>
</div>
<a class="anchor" id="aab9ba1b7362f0ee5716726ffd6ecfab6"></a><!-- doxytag: member="NB_Blackadder::publish_data" ref="aab9ba1b7362f0ee5716726ffd6ecfab6" args="(const string &amp;id, char strategy, void *str_opt, unsigned int str_opt_len, void *data, int data_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::publish_data </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a PUBLISH_DATA request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>the full identifier of the information item for which data is published. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>a bucket of data that is published. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_len</em>&nbsp;</td><td>the size of the published data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6300367f4cb41cb34e3b4231c764350f"></a><!-- doxytag: member="NB_Blackadder::publish_info" ref="a6300367f4cb41cb34e3b4231c764350f" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::publish_info </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a PUBLISH_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>prefix_id CANNOT be an empty string.</p>
<p>If id is a single fragment, the request is about publishing a new information item.</p>
<p>If id consists of multiple fragments, the request is about republishing an existing information item under an existing scope.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>the identifier of an information item. It can be a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>the identifier of the father scope. It can be a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7411bebc92c46cad19844b00b2b9be38"></a><!-- doxytag: member="NB_Blackadder::publish_scope" ref="a7411bebc92c46cad19844b00b2b9be38" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::publish_scope </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a PUBLISH_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>If prefix_id is an empty string, the request is about a root scope.</p>
<p>If id is a single fragment, the request is about publishing a new scope.</p>
<p>If id consists of multiple fragments, the request is about republishing an existing scope under an existing scope.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>the identifier of a scope. It can be a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>the identifier of the father scope. It can be an empty string, a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecab2849b7ee8ff81df9d2aa5b977b1d"></a><!-- doxytag: member="NB_Blackadder::selector" ref="aecab2849b7ee8ff81df9d2aa5b977b1d" args="(void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * NB_Blackadder::selector </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the selector thread execution method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a136fb87bb99f7a91da894075e0f85429"></a><!-- doxytag: member="NB_Blackadder::setCallback" ref="a136fb87bb99f7a91da894075e0f85429" args="(callbacktype t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::setCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNB__Blackadder.html#aa3131e1b0f023cf525c688bd54d095e1">callbacktype</a>&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method registers a user provided call back with <a class="el" href="classNB__Blackadder.html" title="(User Library) This is the wrapper class that makes the service model available to...">NB_Blackadder</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>a pointer to the callback function (of type callbacktype) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3897f32d9bf567384b8083c9d2648e61"></a><!-- doxytag: member="NB_Blackadder::signal_handler" ref="a3897f32d9bf567384b8083c9d2648e61" args="(int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::signal_handler </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the signal handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sig</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c58d8d15f0696bdfa51e70ffbe43b4e"></a><!-- doxytag: member="NB_Blackadder::subscribe_info" ref="a4c58d8d15f0696bdfa51e70ffbe43b4e" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::subscribe_info </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a SUBSCRIBE_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>prefix_id CANNOT be the empty string.</p>
<p>If id is a single fragment, the request is about unpublishing a scope.</p>
<p>id CANNOT consist of multiple fragments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>id the identifier of an information item. It can be a single fragment with size PURSUIT_ID_LEN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>prefix_id the identifier of the father scope. It can be a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6668b38f60d9326e406a1f4f8c1ccfbe"></a><!-- doxytag: member="NB_Blackadder::subscribe_scope" ref="a6668b38f60d9326e406a1f4f8c1ccfbe" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::subscribe_scope </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a SUBSCRIBE_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>If prefix_id is the empty string, the request is about a root scope.</p>
<p>If id is a single fragment, the request is about unpublishing a scope.</p>
<p>id CANNOT consist of multiple fragments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>id the identifier of a scope. It can be a single fragment with size PURSUIT_ID_LEN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>prefix_id the identifier of the father scope. It can be an empty string, a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac75d9e9c5eae56450d48866b85e3ae7"></a><!-- doxytag: member="NB_Blackadder::unpublish_info" ref="aac75d9e9c5eae56450d48866b85e3ae7" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::unpublish_info </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a UNPUBLISH_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>prefix_id CANNOT be an empty string.</p>
<p>If id is a single fragment, the request is about unpublishing an information item.</p>
<p>id CANNOT consist of multiple fragments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>the identifier of an information item. It can be a single fragment with size PURSUIT_ID_LEN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>the identifier of the father scope. It can be a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02f4b85a67a19e9535a8de34c2c730ac"></a><!-- doxytag: member="NB_Blackadder::unpublish_scope" ref="a02f4b85a67a19e9535a8de34c2c730ac" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::unpublish_scope </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a UNPUBLISH_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>If prefix_id is the empty string, the request is about a root scope.</p>
<p>If id is a single fragment, the request is about unpublishing a scope.</p>
<p>id CANNOT consist of multiple fragments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>the identifier of a scope. It can be a single fragment with size PURSUIT_ID_LEN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>the identifier of the father scope. It can be an empty string, a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa20177b292e2abba76953607140e8fc3"></a><!-- doxytag: member="NB_Blackadder::unsubscribe_info" ref="aa20177b292e2abba76953607140e8fc3" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::unsubscribe_info </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a UNSUBSCRIBE_INFO request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>prefix_id CANNOT be the empty string.</p>
<p>If id is a single fragment, the request is about unpublishing a scope.</p>
<p>id CANNOT consist of multiple fragments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>id the identifier of an information item. It can be a single fragment with size PURSUIT_ID_LEN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>prefix_id the identifier of the father scope. It can be a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf41b36a23f9a9923dcdde161163fedf"></a><!-- doxytag: member="NB_Blackadder::unsubscribe_scope" ref="aaf41b36a23f9a9923dcdde161163fedf" args="(const string &amp;id, const string &amp;prefix_id, unsigned char strategy, void *str_opt, unsigned int str_opt_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NB_Blackadder::unsubscribe_scope </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>str_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>str_opt_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>this method will send a UNSUBSCRIBE_SCOPE request to blackadder. <b>It won't block. Instead the request buffer will be put in a queue and the selector thread will be notified to send the request to blackadder.</b> </p>
<p>If prefix_id is the empty string, the request is about a root scope.</p>
<p>If id is a single fragment, the request is about unpublishing a scope.</p>
<p>id CANNOT consist of multiple fragments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>id the identifier of a scope. It can be a single fragment with size PURSUIT_ID_LEN. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix_id</em>&nbsp;</td><td>prefix_id the identifier of the father scope. It can be an empty string, a single fragment with size PURSUIT_ID_LEN or multiple fragments PURSUIT_ID_LEN each. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>the dissemination strategy assigned to the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt</em>&nbsp;</td><td>a bucket of bytes that are strategy specific. When the IMPLICIT_RENDEZVOUS strategy is used this bucket contains a LIPSIN identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str_opt_len</em>&nbsp;</td><td>the size of the provided bucket of bytes. When the IMPLICIT_RENDEZVOUS strategy is used str_opt_len should be FID_LEN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bdddb82721618ddeae7be3e62f645d8"></a><!-- doxytag: member="NB_Blackadder::worker" ref="a7bdddb82721618ddeae7be3e62f645d8" args="(void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * NB_Blackadder::worker </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The worker thread execution method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a447c553da0515bfa0ffb6ef1710e23d4"></a><!-- doxytag: member="NB_Blackadder::defaultCallback" ref="a447c553da0515bfa0ffb6ef1710e23d4" args="(Event *ev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void defaultCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEvent.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>ev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the default Callback that will be whenever an event is received if the application hasn't registered its own callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>A pointer to an already constructed <a class="el" href="classEvent.html" title="(User Library) An event is what can be always expected by Blackaddder. Events are...">Event</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a19100c8df266988e6868088ac3bdca75"></a><!-- doxytag: member="NB_Blackadder::selector_thread" ref="a19100c8df266988e6868088ac3bdca75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t <a class="el" href="classNB__Blackadder.html#a19100c8df266988e6868088ac3bdca75">NB_Blackadder::selector_thread</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The selector Thread (see details). </p>
<p>The selector thread always blocks to the select() method. If the netlink socket is only registered for reading, select() unblocks only when an <a class="el" href="classEvent.html" title="(User Library) An event is what can be always expected by Blackaddder. Events are...">Event</a> is sent by blackadder. When a request is ready to be sent to blackadder, a dummy message is sent to the pipe in which the selector thread always includes it in the reading fd_set. AT that point the netlink socket is also registered for writing. When the socket will unblock again it will send the message to blackadder. </p>

</div>
</div>
<a class="anchor" id="ad44390459d75a021449f7beb45970dad"></a><!-- doxytag: member="NB_Blackadder::worker_thread" ref="ad44390459d75a021449f7beb45970dad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t <a class="el" href="classNB__Blackadder.html#ad44390459d75a021449f7beb45970dad">NB_Blackadder::worker_thread</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the worker thread (see details). </p>
<p>The worker thread always blocks in the worker_cond. The selector thread signals that condition whenever a new event from blackadder was read. The worker thread unblocks, reads the event from the event_queue and calls the application-defined callback method. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/<a class="el" href="nb__blackadder_8hpp_source.html">nb_blackadder.hpp</a></li>
<li>lib/nb_blackadder.cpp</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Apr 6 10:06:20 2012 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
